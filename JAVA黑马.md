### 01.09_Java语言基础(JRE和JDK的概述)(掌握)
* A:什么是JRE
	* 包括Java虚拟机(JVM Java Virtual Machine)和Java程序所需的核心类库等，如果想要运行一个开发好的Java程序，计算机中只需要安装JRE即可。
	* JRE:JVM+类库。 
* B:什么是JDK
	* JDK是提供给Java开发人员使用的，其中包含了java的开发工具，也包括了JRE。所以安装了JDK，就不用在单独安装JRE了。
	* 其中的开发工具：编译工具(javac.exe)  打包工具(jar.exe)等
 	* JDK:JRE+JAVA的开发工具。
* C:为什么JDK中包含一个JRE
	* 为什么JDK中包含一个JRE呢？
		* 开发完的程序，需要运行一下看看效果。
* D:JDK,JRE,JVM的作用和关系
### 01.17_Java语言基础(Path环境变量的配置方式2)(掌握)
* A:先配置JAVA_HOME
* B:再修改path
* C:最后说一下path是有先后顺序关系的
  
* path和classpath的区别
	* path配置的是可执行的文件.exe,配置后可以在不同的盘符下访问path路径下的可执行文件
	* classpath配置的java的类文件,就是.class文件
### 01.21_Java语言基础(关键字的概述和使用)(掌握)
* A:什么是关键字
	* 被Java语言赋予特定含义的单词 
* B:关键字的特点
	* 组成关键字的字母全部小写 
* C:常见关键字
	* public static void class等 
* D:关键字的注意事项
	* goto和const作为保留字存在,目前并不使用,类似Editplus这样的高级记事本,针对关键字有特殊的颜色标记，非常直观 
### 01.22_Java语言基础(标识符的概述和组成规则)(掌握)
* A:什么是标识符
	* 就是给类,接口,方法,变量等起名字时使用的字符序列 
* B:标识符的组成规则
	* 英文大小写字母
	* 数字字符
	* $和_ 
* C:标识符注意事项
	* 1,不能使用关键字
	* 2,不能数字开头 
### 01.23_Java语言基础(标识符中常见的命名规则)(了解)
* 见名知意
* A:包
	* 最好是域名倒过来,要求所有的字母小写 
* B:类或者接口
	* 如果是一个单词首字母大写
	* 如果是多个单词每个单词首字母大写(驼峰标识) 
* C:方法或者变量
	* 如果是一个单词全部小写
	* 如果是多个单词,从第二个单词首字母大写 
* D:常量
	* 如果是一个单词,所有字母大写
	* 如果是多个单词,所有的单词大写,用下划线区分每个单词 
## day03笔记
### 03.02_Java语言基础(逻辑运算符&&和&的区别)(掌握)
* A:案例演示
	* &&和&的区别?
		* a:最终结果一样。
		* b:&&具有短路效果。左边是false，右边不执行。
		* 	&是无论左边是false还是true,右边都会执行
* B:同理||和|的区别?(和&&预&的区别一样)
* C:开发中常用谁?
	* &&,||,!
### 03.03_Java语言基础(位运算符的基本用法1)(了解)
* A:位运算符有哪些
	* &,|,^,~ ,>>,>>>,<<,没有<<<
* B:案例演示
	* 位运算符的基本用法1
	
	* &,|,^,~ 的用法
	* &:有0则0
	* |:有1则1
	* ^:相同则0，不同则1
	* ~:按位取反
### 03.04_Java语言基础(位异或运算符的特点及面试题)(掌握)
* A:案例演示
	* 位异或运算符的特点
  
	* ^的特点：一个数据对另一个数据位异或两次，该数本身不变。  
    System.out.println(5 ^ 10 ^ 10);  //结果是5  
    System.out.println(5 ^ 10 ^ 5); //结果是10  
* B:面试题：
	* 请自己实现两个整数变量的交换  
  	  int x = 10;  
      int y = 5;  
      //不需要定义第三方变量,有可能超出int的取值范围.  
      x = x + y;  
      y = x - y;  
      x = x - y;  
      //不需要定义第三方变量,通过^来做.  
      x = x ^ y;  //10 ^ 5  
      y = x ^ y;  //10 ^ 5 ^ 5, y = 10  
      x = x ^ y;  //10 ^ 5 ^ 10, x = 5  
      
### 03.05_Java语言基础(位运算符的基本用法2及面试题)(了解)
* A:案例演示 >>,>>>,<<的用法:
```
  <<:左移	左边最高位丢弃，右边补齐0
  >>:右移	最高位是0，左边补齐0;最高为是1，左边补齐1
  >>>:无符号右移 无论最高位是0还是1，左边补齐0  

  //左移,向左移动几位就是乘以2的几次幂  
  System.out.println(12 << 1);		//24  
  System.out.println(12 << 2);		//48  
  //右移,向右移动几位就是除以2的几次幂  
  System.out.println(12 >> 1);  
  System.out.println(12 >> 2);  
  //最有效率的算出2 * 8的结果  
  System.out.println(2 << 3);  
```
    
### 03.21_Java语言基础(选择结构switch语句的注意事项)(掌握)
* A:案例演示
	* a:case后面只能是常量，不能是变量，而且，多个case后面的值不能出现相同的
	* b:default可以省略吗?
		* 可以省略，但是不建议，因为它的作用是对不正确的情况给出提示。
		* 特殊情况：
			* case就可以把值固定。
			* A,B,C,D
	* c:break可以省略吗?
		* 最后一个可以省略,其他最好不要省略
		* 会出现一个现象：case穿透。
		* 最终我们建议不要省略
	* d:default一定要在最后吗?
		* 不是，可以在任意位置。但是建议在最后。
	* e:switch语句的结束条件
		* a:遇到break就结束了
		* b:执行到switch的右大括号就结束了
    
    //B:看程序写结果：

		int x = 2;
		int y = 3;
		switch(x){
			default:
				y++;
			case 3:
				y++;
			case 4:
				y++;
		}
		System.out.println("y="+y);//结果是6,碰到}才结束.  
    
### 04.13_Java语言基础(循环结构九九乘法表)
* A:案例演示
	* 需求：在控制台输出九九乘法表。
* B:代码优化
* 
		注意：
		'\x' x表示任意，\是转义符号,这种做法叫转移字符。放在单引号可以,放在双引号也可以.  
		
		'\t'	tab键的位置
		'\r'	回车
		'\n'	换行
		'\"'
		'\''
### 04.16_Java语言基础(控制跳转语句标号)  
* 标号:标记某个循环对其控制  
```
  outer: for (int i = 1;i <= 10 ;i++ ) {		//outer就是标号,只要是合法的标识符即可,例如可以是a.  
    System.out.println("i = " + i);  
    inner: for (int j = 1;j <= 10 ;j++ ) {  
      System.out.println("j = " + j);  
      break outer;//用于跳出外层循环  
    }  
  }  
```
* 标号组成规则:其实就是合法的标识符  
```
  下面这个语句是正确的.http:是标号,//后面是注释
  System.out.println("大家好");
  http://www.heima.com
  System.out.println("才是真的好");
  最终输出结果是:
  大家好
  才是真的好
```
### 04.18_Java语言基础(控制跳转语句return语句)
* A:return的作用
	* 返回
	* 其实它的作用不是结束循环的，而是结束方法的。
* B:案例演示
	* return和break以及continue的区别?
	* return是结束方法
	* break是跳出循环
	* continue是终止本次循环继续下次循环
### 04.25_Java语言基础(方法重载概述和基本使用)
* A:方法重载概述
	* 求和案例
		* 2个整数
		* 3个整数
		* 4个整数
* B:方法重载：
	* 在同一个类中，方法名相同，参数列表不同。与返回值类型无关。
	
	* 参数列表不同：
		* A:参数个数不同
		* B:参数类型不同
		* C:参数的顺序不同(算重载,但是在开发中不用)
### 05.03_Java语言基础(Java中的内存分配以及栈和堆的区别)  
.class文件运行在内存上,分为下面的几部分:  
* A:栈(掌握)
	* 存储局部变量 
	局部变量:定义在方法声明上和方法中的变量
* B:堆(掌握)
	* 存储new出来的数组或对象 
* C:方法区
	* 面向对象部分讲解(相当于我们的代码仓库,源文件->字节码文件(.class)->内存(方法区)) 
* D:本地方法区
	* 和系统相关 
* E:寄存器
	* 给CPU使用
### 05.07_Java语言基础(数组的初始化静态初始化及内存图)  
* A:静态初始化的格式：
	* 格式：数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};
	* 简化格式：数据类型[] 数组名 = {元素1,元素2,…};  
```
//数据类型[] 数组名 = new 数据类型[]{元素1,元素2,…};
//int[] arr = new int[5]{11,22,33,44,55};	//不允许动静结合
int[] arr2 = {11,22,33,44,55};			//静态初始化的简写形式

//int[] arr;					//声明数组引用,无错误.
//arr = new int[]{11,22,33,44,55};

//int[] arr2;
//arr2 = {11,22,33,44,55};			//简写形式声明和赋值在同一行,有错误.
```
### 05.11_Java语言基础(数组的操作3翻转)  
```
/*
数组元素反转
1,明确返回值类型void
2,明确参数列表int[] arr
*/

public static void reverseArray(int[] arr) {
	for (int i = 0;i < arr.length / 2 ; i++) {
		//arr[0]和arr[arr.length-1-0]交换
		//arr[1]和arr[arr.length-1-1]交换
		//arr[2]和arr[arr.lentth-1-2]
		//...

		int temp = arr[i];
		arr[i] = arr[arr.length-1-i];
		arr[arr.length-1-i] = temp;
	}
}
```
### 05.11_Java语言基础(二维数组概述和格式1的讲解)  
```
/*
* A:二维数组概述
* B:二维数组格式1
	* int[][] arr = new int[3][2]; 
* C:二维数组格式1的解释
* D:注意事项
	* a:以下格式也可以表示二维数组
		* 1:数据类型 数组名[][] = new 数据类型[m][n];
		* 2:数据类型[] 数组名[] = new 数据类型[m][n];
	* B:注意下面定义的区别
	* 
			int x;
			int y;
			int x,y;
			
			int[] x;
			int[] y[];
			
			int[] x,y[];	x是一维数组,y是二维数组
*/
```
### 05.20_Java语言基础(Java中的参数传递问题及图解)  
```
/*
基本数据类型的值传递,不改变原值,因为调用后就会弹栈,局部变量随之消失
引用数据类型的值传递,改变原值,因为即使方法弹栈,但是堆内存数组对象还在,可以通过地址继续访问

Java中到底是传值还是传址
1,既是传值,也是传地址,基本数据类型传递的值,引用数据类型传递的地址
2,java中只有传值,因为地址值也是值(出去面试都说这种,支持者是高司令(java之父))
*/
```
* 基本数据类型的值传递:  
![基本数据类型的值传递](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Value%20transfer%20of%20basic%20data%20type.png)  
  
* 引用数据类型的值传递:  
![引用数据类型的值传递](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Value%20transfer%20of%20reference%20data%20type.png)  

### 06.01_面向对象(面向对象思想概述)(了解)  
* D:面向对象思想特点
	* a:是一种更符合我们思想习惯的思想
	* b:可以将复杂的事情简单化
	* c:将我们从执行者变成了指挥者
* G:面向对象特征
	* 封装(encapsulation)
	* 继承(inheritance)
	* 多态(polymorphism)

### 06.07_面向对象(一个对象的内存图)(掌握)  
* A:画图演示
	* 一个对象  
![引用数据类型的值传递](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Memory%20graph%20of%20one%20object.png)  
  
### 06.10_面向对象(成员变量和局部变量的区别)(掌握)  
* A:在类中的位置不同
	* 成员变量：在类中方法外
	* 局部变量：在方法定义中或者方法声明上
* B:在内存中的位置不同
	* 成员变量：在堆内存(成员变量属于对象,对象进堆内存)
	* 局部变量：在栈内存(局部变量属于方法,方法进栈内存)
* C:生命周期不同
	* 成员变量：随着对象的创建而存在，随着对象的消失而消失
	* 局部变量：随着方法的调用而存在，随着方法的调用完毕而消失
* D:初始化值不同
	* 成员变量：有默认初始化值
	* 局部变量：没有默认初始化值，必须定义，赋值，然后才能使用。
	
* 注意事项：
	* 局部变量名称可以和成员变量名称一样，在方法中使用的时候，采用的是就近原则。
	* 基本数据类型变量包括哪些:byte,short,int,long,float,double,boolean,char
	* 引用数据类型变量包括哪些:数组,类,接口,枚举
### 06.12_面向对象(匿名对象的概述和应用)(掌握)  
* A:什么是匿名对象
	* 没有名字的对象 
* B:匿名对象应用场景
	* a:调用方法，仅仅只调用一次的时候。
		* 那么，这种匿名调用有什么好处吗?
			* 节省代码 
		* 注意：调用多次的时候，不适合。匿名对象调用完毕就是垃圾。可以被垃圾回收器回收。
	* b:匿名对象可以作为实际参数传递
* C:案例演示
	* 匿名对象应用场景
```
class Demo2_Car {
	public static void main(String[] args) {
		/*Car c1 = new Car();			//创建有名字的对象
		c1.run();
		c1.run();

		new Car().run();			//匿名对象调用方法
		new Car().run();	*/		//匿名对象只适合对方法的一次调用,因为调用多次就会产生多个对象,不如用有名字的对象	
	
		//匿名对象是否可以调用属性并赋值?有什么意义?
		/*
		匿名对象可以调用属性,但是没有意义,因为调用后就变成垃圾
		如果需要赋值还是用有名字对象
		*/
		new Car().color = "red";
		new Car().num = 8;
		new Car().run();
	}
}

class Car {
	String color;			//颜色
	int num;			//轮胎数

	public void run() {
		System.out.println(color + "..." + num);
	}
}
```
### 06.13_面向对象(封装的概述)(掌握)
* A:封装概述
	* 是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

* B:封装好处
	* 隐藏实现细节，提供公共的访问方式
	* 提高了代码的复用性
	* 提高安全性。
* C:封装原则
	* 将不需要对外提供的内容都隐藏起来。
	* 把属性隐藏，提供公共方法对其访问。
### 06.14_面向对象(private关键字的概述和特点)(掌握)
* A:人类赋值年龄的问题
* B:private关键字特点
	* a:是一个权限修饰符
	* b:可以修饰成员变量和成员方法
	* c:被其修饰的成员只能在本类中被访问
* C:案例演示
	* 封装和private的应用：
	* A:把成员变量用private修饰
	* B:提供对应的getXxx()和setXxx()方法//这个最重要了,取值;有getXxx()和setXxx()方法的叫java bean类  
	* private仅仅是封装的一种体现形式,不能说封装就是私有	
### 06.15_面向对象(this关键字的概述和应用)(掌握)
* A:this关键字特点
	* 代表当前对象的引用 
* B:案例演示
	* this的应用场景
	* 用来区分成员变量和局部变量重名
### 07.01_面向对象(构造方法Constructor概述和格式)(掌握)
* A:构造方法概述和作用
	* 给对象的数据(属性)进行初始化
* B:构造方法格式特点
	* a:方法名与类名相同(大小也要与类名一致)
	* b:没有返回值类型，连void都没有
	* c:没有具体的返回值return;构造方法也是有return语句的,格式是return;;
	* d:构造方法不能用对象调用.
### 07.02_面向对象(构造方法的重载及注意事项)(掌握)
* A:案例演示
	* 构造方法的重载
	* 重载:方法名相同,与返回值类型无关(构造方法没有返回值),只看参数列表
* B:构造方法注意事项
	* a:如果我们没有给出构造方法，系统将自动提供一个无参构造方法。
	* b:如果我们给出了构造方法，系统将不再提供默认的无参构造方法。
		* 注意：这个时候，如果我们还想使用无参构造方法，就必须自己给出。建议永远自己给出无参构造方法
### 07.06_面向对象(创建一个对象的步骤)(掌握)
* A:画图演示
	* 画图说明一个对象的创建过程做了哪些事情?
	* Student s = new Student();
	* 1,Student.class加载进内存
	* 2,声明一个Student类型引用s
	* 3,在堆内存创建对象,
	* 4,给对象中属性默认初始化值
	* 5,属性进行显示初始化
	* 6,构造方法进栈,对对象中的属性赋值,构造方法弹栈
	* 7,将对象的地址值赋值给s
![创建一个对象的步骤](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/To%20create%20an%20object.png)  
### 07.10_面向对象(static关键字的特点)(掌握)
* A:static关键字的特点
	* a:随着类的加载而加载
	* b:优先于对象存在
	* c:被类的所有对象共享
		* 举例：咱们班级的学生应该共用同一个班级编号。
		* 其实这个特点也是在告诉我们什么时候使用静态?
			* 如果某个成员变量是被所有对象共享的，那么它就应该定义为静态的。
		* 举例：
			* 饮水机(用静态修饰)
			* 水杯(不能用静态修饰)
			* 共性用静态,特性用非静态
	* d:可以通过类名调用
		* 其实它本身也可以通过对象名调用。
		* **推荐**使用类名调用。
		* 静态修饰的内容一般我们称其为：与类相关的，类成员
* B:案例演示
	* static关键字的特点
### 07.11_面向对象(static的注意事项)(掌握)
* A:static的注意事项
	* a:在静态方法中是没有this关键字的
		* 如何理解呢?
			* 静态是随着类的加载而加载，this是随着对象的创建而存在。
			* 静态比对象先存在。
	* b:静态方法只能访问静态的成员变量和静态的成员方法
		* 静态方法：
			* 成员变量：只能访问静态变量
			* 成员方法：只能访问静态成员方法
		* 非静态方法：
			* 成员变量：可以是静态的，也可以是非静态的
			* 成员方法：可是是静态的成员方法，也可以是非静态的成员方法。
		* 简单记：
			* 静态只能访问静态。(**总结:类不能访问实例,或者叫做静态不能访问非静态.**)
* B:案例演示
	* static的注意事项
### 07.12_面向对象(静态变量和成员变量的区别)(掌握)
* **静态变量也叫类变量  成员变量也叫对象变量**
* A:所属不同
	* 静态变量属于类，所以也称为为类变量
	* 成员变量属于对象，所以也称为实例变量(对象变量)
* B:内存中位置不同
	* 静态变量存储于方法区的静态区
	* 成员变量存储于堆内存
* C:内存出现时间不同
	* 静态变量随着类的加载而加载，随着类的消失而消失
	* 成员变量随着对象的创建而存在，随着对象的消失而消失
* D:调用不同
	* 静态变量可以通过类名调用，也可以通过对象调用
	* 成员变量只能通过对 象名调用
### 07.13_面向对象(main方法的格式详细解释)(了解)
* A:格式
	* public static void main(String[] args) {}
* B:针对格式的解释
	* public 被jvm调用，访问权限足够大。
	* static 被jvm调用，不用创建对象，直接类名访问
	* void被jvm调用，不需要给jvm返回值
	* main 一个通用的名称，虽然不是关键字，但是被jvm识别
	* String[] args 以前用于接收键盘录入的
* C:演示案例
	* 通过args接收键盘例如数据
```
class Demo3_Main {
	public static void main(String[] args) {			
		System.out.println(args.length);
		for (int i = 0;i < args.length ;i++ ) {
			System.out.println(args[i]);
		}
	}
}

cmd输入:java Demo3_Main haha xixi hehe
cmd输出:
3
haha
xixi
hehe
```
### 07.14_面向对象(工具类中使用静态)(了解)
* A:制作一个工具类
	* ArrayTool
	* 1,获取最大值
	* 2,数组的遍历
	* 3,数组的反转
* 如果一个类中所有的方法都是静态的,需要再多做一步,**私有构造方法**,目的是不让其他类创建本类对象,直接用类名.调用即可
### 07.15_面向对象(说明书的制作过程)(了解)
* A:对工具类加入文档注释
* B:通过javadoc命令生成说明书
	* @author(提取作者内容)
	* @version(提取版本内容)
	* javadoc -d 指定的文件目录 -author -version ArrayTool.java  (类必须是public的)
	* @param 参数名称//形式参数的变量名称
	* @return 函数运行完返回的数据
