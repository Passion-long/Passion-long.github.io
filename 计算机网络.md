# 计算机网络

* 什么是三次握手？  
  
![三次握手](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Three_handshakes.png)  
第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；  
第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；  
第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。  
  
* TCP建立连接可以两次握手吗？为什么？  
答：不可以。首先，可能会出现已失效的连接请求报文段又传到了服务器端（就是Client无法向Server的确认发出确认）。  
其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。  
  
* 可以采用四次握手吗？为什么？  
答：可以。但是会降低传输的效率。  

* 什么是四次挥手？  
  
![四次握手](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Four_waves.png)  
第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；  
第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。  
第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；  
第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。  
  
* 
