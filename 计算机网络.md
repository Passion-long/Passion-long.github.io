# 计算机网络
## 传输层：TCP和UDP  

1. 什么是三次握手？  
  
![三次握手](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Three_handshakes.png)  
第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；  
第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；  
第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。  
  
2. TCP建立连接可以两次握手吗？为什么？  
答：不可以。首先，可能会出现已失效的连接请求报文段又传到了服务器端（就是Client无法向Server的确认发出确认）。  
其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。  
  
3. 可以采用四次握手吗？为什么？  
答：可以。但是会降低传输的效率。  

4. 什么是四次挥手？  
  
![四次握手](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Four_waves.png)  
第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；  
第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。  
第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；  
第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。  
  
5. 客户端TIME_WAIT的意义是什么？（为什么要等待2MSL）？  
答：第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。  
  
6. TCP和UDP的区别是什么？  
* TCP是面向连接的，UDP是无连接的。  
* TCP可靠，UDP不可靠。  
* TCP只支持点对点通信，UDP支持一对一，一对多，多对一，多对多。  
* TCP是面向字节流的，UDP是面向报文的。  
* TCP有拥堵控制机制，UDP没有。  
* TCP首部开销（20字节）比UDP首部开销（8字节）要大。  
* UDP主机不需要维持复杂的连接状态表。  
  
7. 选择题：TCP不确保数据能按续到达。  
  
8. TCP如何保证传输的可靠性？  
* 数据包校验  
* 对失序数据包重新排序（TCP报文具有序列号）  
* 丢弃重复数据  
* 应答机制  
* 超时重发  
* 流量控制  

  
9. https的连接过程？  
* 客户端发送请求到客户端。  
* 服务端返回公钥和证书到客户端。  
* 客户端接收后会验证证书的安全性，如果通过则会随机生成一个随机数，用证书中的公钥对其加密，发送到服务端。  
* 服务端接收到这个加密后的随机数后会用私钥对其解密得到真正的随机数，随后用这个随机数当做私钥（对称密钥）对需要发送的数据进行对称加密。  
* 客户端在接收到加密后的数据使用私钥（即生成的随机数）对数据进行解密并且解析数据呈现结果给客户。  
* SSL加密建立。  
  
## 应用层：HTTP和HTTPS  
1. HTTP和HTTPS的区别是什么？  
* 端口不同：http使用80端口，https使用443端口。  
* http信息是明文传输，https运行在SSL之上，添加了加密和认证机制，更加安全。  
* https由于加密解密会带来更大的CPU和内存消耗。  
* https通信需要证书，一般需要向证书颁发机构购买。  
  
2. 输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？  
* 一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。 解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。  
  
3. 什么是对称加密、非对称加密？区别是什么？  
* 对称加密：加密和解密采用相同的密钥。  
* 非对称加密：如果用公钥加密，需要用私钥才能解密。  
* 区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高   
  
4. 在客户端和服务器之间进行请求——响应时，两种最常被用到的方法是：GET和POST。  
* GET——从指定的资源请求数据  
* POST——向指定的资源提交要被处理的数据  
  
5. GET和POST的区别是什么？  
* GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；  
* GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；  
* 请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；  
* 安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；  
* GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；  
* GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制  
  
6. Session和Cookie的区别是什么？  
* Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案  
* Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。  
  
7. 从输入网址到获得页面的过程？（或输入URL之后的过程？）   
* 浏览器查询DNS，获取域名对应的IP地址。  
* 浏览器向服务器请求建立连接，发起三次握手。  
* TCP/IP连接建立起来后，浏览器向服务器发送HTTP请求。  
* 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。  
* 浏览器解析并渲染视图，若遇到对js文件，css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源。  
* 浏览器根据其请求到的资源、数据渲染页面，最终向用于呈现一个完整的页面。  
  
## 网络层协议  
1. 什么是RIP（路由信息协议）？  
* 每个路由器维护一张表，记录该路由器到其他网络的“跳数”，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1,。交付数据报时优先选取距离最近的路径。  
  
2.  什么是ARP协议 (Address Resolution Protocol)？  
* ARP完成了IP地址和物理地址的映射。  
  
3.  什么是NAT (Network Address Translation, 网络地址转换)？  
* 用于解决内网中的主机和因特网中的主机通信。  

4. HTTP请求有哪些常见的状态码？  
* 2XX状态码：操作成功  
* 3XX状态码：重定向  
* 4XX状态码：客户端错误
  * 403 Forbidden 服务器拒绝请求  
  * 404 NotFound 未找到资源  
  * 405 Method Not Allowed 不允许使用的方法  
* 5XX状态码：服务端错误  
  
5. 网络的OSI模型是什么？  
* 应用层、表示层、会话层、传输层、网络层、数据链路层、物理层  
  
6. DNS是什么层？原理是什么？  
* 应用层。原理：浏览器输入地址，然后浏览器这个进程区调操作系统某个库里的gethostbyname函数，然后这个函数通过网卡给DNS服务器发UDP请求，接收结果，然后将结果返回给浏览器。  
  
7. 在公司局域网上ping www.bilibili.com没有涉及到的网络协议是？**TCP**  
* 用到了DNS域名解析，ICMP请求回显数据包，ARP通过IP获取MAC地址。  
  
8. 
