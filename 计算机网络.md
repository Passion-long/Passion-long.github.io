# 计算机网络

1. 什么是三次握手？  
  
![三次握手](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Three_handshakes.png)  
第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；  
第二次握手：Server收到Client的SYN=1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number=sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；  
第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number=服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。  
  
2. TCP建立连接可以两次握手吗？为什么？  
答：不可以。首先，可能会出现已失效的连接请求报文段又传到了服务器端（就是Client无法向Server的确认发出确认）。  
其次，两次握手无法保证Client正确接收第二次握手的报文（Server无法确认Client是否收到），也无法保证Client和Server之间成功互换初始序列号。  
  
3. 可以采用四次握手吗？为什么？  
答：可以。但是会降低传输的效率。  

4. 什么是四次挥手？  
  
![四次握手](https://github.com/Passion-long/Passion-long.github.io/blob/master/Figure/Four_waves.png)  
第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；  
第二次挥手：Server收到FIN之后，发送一个ACK=1，acknowledge number=收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。  
第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；  
第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number=序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。  
  
5. 客户端TIME_WAIT的意义是什么？（为什么要等待2MSL）？  
答：第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。  
  
6. TCP和UDP的区别是什么？  
* TCP是面向连接的，UDP是无连接的。  
* TCP可靠，UDP不可靠。  
* TCP只支持点对点通信，UDP支持一对一，一对多，多对一，多对多。  
* TCP是面向字节流的，UDP是面向报文的。  
* TCP有拥堵控制机制，UDP没有。  
* TCP首部开销（20字节）比UDP首部开销（8字节）要大。  
* UDP主机不需要维持复杂的连接状态表。  
  
7. 选择题：TCP不确保数据能按续到达。  
  
8. TCP如何保证传输的可靠性？  
* 数据包校验  
* 对失序数据包重新排序（TCP报文具有序列号）  
* 丢弃重复数据  
* 应答机制  
* 超时重发  
* 流量控制  

  
9. 

