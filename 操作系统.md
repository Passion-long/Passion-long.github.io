# 操作系统  
[《计算机操作系统》知识点复习可以参考这个链接](https://blog.csdn.net/COCO56/article/details/101201389)  
## 操作系统的基本特性  
  
1. 并行和并发有什么区别？  
* 并行是指两个或多个事件在同一时刻发生；  
* 并发性是指在一段时间内宏观上有多个程序在同时运行，但在单机处理系统中，每一时刻却仅能有一道程序执行，故微观上这些程序只能是分时地交替执行。  
  
2. 什么叫虚拟？  
* 在OS中，把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”。相应的，把用于实现虚拟的技术称为虚拟技术。在OS中也是利用时分复用和空分复用技术来实现“虚拟”的。  
  
<details>  
<summary>时分复用技术：</summary>  
   
利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。  
   
</details>  
  
<details>  
<summary>空分复用技术：</summary>  
   
利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率。  
   
</details>  

<details>  
<summary>虚拟存储技术：</summary>  
   
虚拟存储技术在本质上是实现内存的分时复用，即它可以通过分时复用内存的方式，使一道程序仅在远小于它的内存空间中运行。  
   
</details>  
  
3. 什么叫异步(Asynchronism)？  
* 在多道程序环境下，系统允许多个进程并发执行。进程是以人们不可预知的速度向前推进的，此即进程的异步性。  
  
4. 什么叫面向对象的程序设计？  
* 所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物（事物可以是一个物理实体、一个概念或一个软件模块等）的抽象，而把其中的具体事物称为对象的实例。（类是在对象上的抽象，对象则是类的实例）  
  
## 进程的描述与控制  




## 进程和线程  
1. 进程和线程有什么区别？  
* 进程（Process）是系统分配资源的基本单位，线程（Thread）是CPU执行操作的基本单位；  
* 线程依赖于进程而存在，一个进程至少有一个线程；  
* 进程有自己的独立地址空间，线程共享所属进程的地址空间；  
* 进程是拥有系统资源的一个独立单位，而线程自己基本上不拥有系统资源，线程共享本进程的相关资源如内存、I/O、cpu等；  
* 进程切换的开销远大于线程切换的开销；   
* 线程之间的通信更方便，同一进程下的线程共享全局变量等数据，而进程之间的通信需要以进程间通信(IPC)的方式进行；  
* 多线程程序只要有一个线程崩溃，整个程序就崩溃了，但多进程程序中一个进程崩溃并不会对其它进程造成影响，因为进程有自己的独立地址空间，因此多进程更加健壮。  
  
2. CPU调度基本单位：线程。  
  
3. 线程的堆和静态变量可以共享。  
  
4. 进程通信方式，以及干嘛用的？  
* 管道（半双工，数据只能单向流动，有血缘关系进程间使用）  
* 有名管道（半双工，允许无血缘关系进程间通信）  
* 信号量（最常用的进程同步机制，控制多个进程对共享资源的访问）  
* 消息队列（由消息组成的链表，克服了信号传递信息少等缺点）  
* 信号（用于通知接收进程某个事件已经发生）  
* 共享内存（映射一段能被其他进程所访问的内存）  
* 套接字（Socket，可用于不同设备的进程通信）  
  
5. 线程通信方式：
* 锁机制  
  * 互斥锁  
  * 读写锁  
  * 条件变量  
* 信号量机制  
* 信号机制  
  
6. 线程同步机制？  
* 临界区（速度快，节省资源）  
* 互斥量  
* 事件  
* 信号量  
  
7. 进程调度策略有哪些？  
* 批处理系统  
  * 先来先服务  
  * 最短作业优先  
  * 最短运行时间优先  
  * 最高响应比优先  
* 交互式系统  
  * 时间片轮转  
  * 优先级调度算法  
  * 多级反馈队列调度算法  
   
8. 协程和线程进行比较？  
* 一个线程可以拥有多个协程，一个进程也可以拥有多个协程。  
* 线程进程都是同步机制， 协程则是异步。  
* 协程能保留上一次调用时的状态（每次过程重入时，就相当于进入上一次调用的状态）。  
  
9. Java线程安全的实现方法？  
* 互斥同步  
* 非阻塞同步  
* 无同步  
  
10. Java线程的6中状态？  
* New（新建）  
* Runnable（可运行）  
* Blocked（阻塞）  
* Waiting（等待）  
* Timed waiting（超时等待）  
* Terminated（终止）  
  
## 锁
1. 什么是锁？  
* 在两个或者多个并发进程中，每个进程持有某种资源而又等待其它进程释放它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁(deadlock)。  
  
2. 死锁产生的必要条件？  
* 互斥：一个资源一次只能被一个进程使用；  
* 占有并等待：一个进程至少占有一个资源，并在等待另一个被其它进程占用的资源；  
* 非抢占：已经分配给一个进程的资源不能被强制性抢占，只能由进程完成任务之后自愿释放；  
* 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系，该环路中的每个进程都在等待下一个进程所占有的资源。  
  
3. 死锁有哪些处理方法？  
* 鸵鸟策略  
* 死锁预防  
* 死锁避免  
* 死锁解除  
  
## 内存管理  
1. 什么是虚拟内存？  
* 每个程序都拥有自己的地址空间，这个地址空间被分成大小相等的页，这些页被映射到物理内存；但不需要所有的页都在物理内存中，当程序引用到不在物理内存中的页时，由操作系统将缺失的部分装入物理内存。这样，对于程序来说，逻辑上似乎有很大的内存空间，只是实际上有一部分是存储在磁盘上，因此叫做虚拟内存。  
  
虚拟内存的优点是让程序可以获得更多的可用内存。  
  
2. 有哪些页面置换算法？  
* 最佳页面置换算法  
* 先进先出  
* 第二次机会算法  
* 时钟算法  
* 最近未使用算法  
* 最近最少使用算法  
* 最不经常使用算法  
  
3. 信号量的应用：  
利用信号量实现进程互斥：  
为使多个进程能互斥地访问某临界资源，只需为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait(mutex)和signal(mutex)操作之间即可。这样，每个欲访问该临界资源的进程在进入临界区之前，都要先对mutex执行wait操作，若该资源此刻未被执行，本次wait操作必然成功，进程便可进入自己的临界区，这时若有其他进程也欲进入自己的临界区，由于对mutex执行wait操作定会失败，因而此时该进程阻塞，从而保证了该临界资源能被互斥地访问。当访问临界资源的进程退出临界区后，又应对mutex执行signal操作，以便释放该临界资源。  
  

<details>  
<summary>4. 生产者-消费者问题（重点）  </summary>  
  
  
生产者消费者【传统版】  
使用synchronized、wait、notify实现  
```  
package test;
public class Main {
    static class Storehouse {
        private int capacity; // 仓库的容量
        private int size; // 仓库的存货量

        /**
         * 初始化仓库的容量和实际存货量
         *
         * @param capacity
         * @param size
         */
        public Storehouse(int capacity, int size) {
            super();
            this.capacity = capacity;
            this.size = size;
        }

        /**
         * 生产指定数量的产品
         *
         * @param count
         *            生产的产品数量
         */
        public synchronized void product(int count) {
            try {
                while (count > 0 ) {
                    if (size >= capacity) {
                        wait();
                    } else {
                        // 计算生产数量 如果生产的数量和现有的数量大于总容量，则生产量为总容量 - 当前容量 否则 生产需要的容量。
                        int inc = (count + size) > capacity ? capacity - size
                                : count;
                        size += inc;
                        count -= inc;
                        System.out.println("本次生产产品：" + inc + "个，当前总产品：" + size
                                + "个");
                    }
                    notifyAll();
                }
            } catch (InterruptedException e) {
            }
        }

        /**
         * 消费制定的产品数量
         *
         * @param count
         *            消费指定的产品数量。
         */
        public synchronized void consume(int count) {
            try {
                while (count > 0) {
                    if (size <= 0) {
                        wait();
                    } else {
                        // 消费产品 如果消费的产品比剩余产品多，就消费掉所有剩余产品。否则就消费需要的产品量
                        int inc = count > size ? size : count;
                        size -= inc;
                        count -= inc;
                        System.out.println("本次消费产品：" + inc + "个，当前总产品：" + size
                                + "个");

                    }
                    notifyAll();
                }

            } catch (InterruptedException e) {
            }
        }
    }

    static class Cusomer{
        private Storehouse storehouse;

        public Cusomer(Storehouse storehouse) {
            super();
            this.storehouse = storehouse;
        }

        public void consume(final int count) {

            new Thread(new Runnable() {
                @Override
                public void run() {
                    storehouse.consume(count);
                }
            },"消费者").start();

        }
    }


    static class Producer{
        private Storehouse storehouse;

        public Producer(Storehouse storehouse) {
            super();
            this.storehouse = storehouse;
        }

        public void product(final int count) {

            new Thread(new Runnable() {
                @Override
                public void run() {
                    storehouse.product(count);
                }
            },"消费者").start();

        }
    }

    public static void main(String[] args) {
        Storehouse storehouse = new Storehouse(100, 0);
        Cusomer cusomer = new Cusomer(storehouse);
        Producer producer = new Producer(storehouse);

        cusomer.consume(10);
        producer.product(110);
        cusomer.consume(50);
        cusomer.consume(70);
        cusomer.consume(20);
        cusomer.consume(100);
        producer.product(60);
        producer.product(10);
        producer.product(510);

    }
}
  
```

</details>  
  
5. 哲学家就餐问题  
  
6. 读者-写者问题  
  
7. 
















